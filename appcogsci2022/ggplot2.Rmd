---
title: "Визуализация в ggplot2: кодим красивое"
author: "Антон Ангельгардт"
date: "7/07/2022"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    
---

> <font size=3> `ggplot2` --- мощный и популярный пакет для визуализации данных. Однако часто построение графиков ограничивается простыми шаблонами и выбором стандартных тем. Сегодня мы разберемся с тонкостями логики построения графика с помощью пакета `ggplot2`, научимся управлять отдельными элементами графика, а также узнаем, как подготовить визуализацию к публикации в соответствии с требованиями журнала, не используя сторонние программы.</font>

# Что есть `ggplot2`?

`ggplot2` --- это внешний пакет языка `R`, который позволяет строить красивые и сложные визуализации. Как и любой `R`-пакет, это набор функций, которые позволяют делать те или иные преобразования с графиками. Пакет `ggplot2` является частью семейства пакетов `tidyverse`.

```{r}
library(tidyverse)
```



# Сверхкраткое введение в `tidyverse`

## Что есть `tidyverse`

`tidyverse` --- это пакет с пакетами для тех, кто занимается дата саенс. Пакеты хорошо стыкуются друг с другом и работают вместе в любви и гармонии, потому что 

> they share common data representations and API design.

`tidyverse` per se, по факту, только обертка, чтобы было удобно скачать весь комплект пакетов. Мясо же распределено между ними.

## Что в пакетах?

* `ggplot2` --- всё для визуализации, наш пакет интереса на сегодня
* `dplyr` --- всякие приблуды для манипулирования с данными
* `tidyr` --- штуки, чтобы привести данные к [tidy-виду](https://habr.com/ru/post/248741/)
* `readr` --- для импорта данных
* `purrr` --- для преисполнившихся в функциональном программировании
* `tibble` --- всё, что связано с tibbles [это как датафреймы, только моднее]
* `stringr` --- всякое для работы со строками
* `forcats` --- разное для работы с факторами


## Что особенного?

**Синтаксис.**

### Велосипедик

`tidyverse` настолько крут, что его него есть свой синтаксис, основная особенность которого --- это пайп (pipe): `%>%`. Вводится через **Ctrl + Shift + M** (**⌘ + Shift + M**). Этот «велосипедик» работает по очень простой схеме: передаёт то, что слева, первым аргументом функции, которая справа. Вот пример:

```{r}
round(pi, 2)
pi %>% round(2)
```

С помощью этого оператора можно выстраивать конвейеры из функций, следующих друг за другом:

```{r}
pi %>% 
  sqrt() %>% 
  round(3) %>% 
  sin() %>% 
  `/`(1, .) %>% 
  exp() %>% 
  round(2)
```

Это существенно повышает redability кода.

# Зачем вообще рисовать?

Рассмотрим два примера.

## Квартет Анскомба

Грузим датасет:

```{r}
quartet <- read_csv("https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/data/anscombe.csv")
```

Считаем описательные статистики:

```{r, echo=FALSE}
quartet %>% 
  group_by(dataset) %>% 
  summarise(mean.x = mean(x),
            sd.x = sd(x),
            mean.y = mean(y),
            sd.y = sd(y),
            cor = cor(x, y),
            n_obs = n()) %>% 
  round(2)
```

Одинаковое.

Рисуем:

```{r, echo=FALSE}
quartet %>% 
  ggplot(aes(x, y)) +
  geom_point() +
  facet_wrap(~dataset, nrow = 2) +
  theme_bw()
```

Разное…


## Datasaurus

Грузим датасет:

```{r}
datasaurus <- read_csv("https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/data/datasaurus.csv")
```

Считаем описательные статистики:

```{r, echo=FALSE}
datasaurus %>% 
  group_by(dataset) %>% 
  summarise(mean.x = mean(x),
            sd.x = sd(x),
            mean.y = mean(y),
            sd.y = sd(y),
            cor = cor(x, y),
            n_obs = n()) %>% 
  mutate_if(is.numeric, function(x) round(x, 1))
```

Одинаковое…

Рисуем:

```{r, echo=FALSE}
datasaurus %>% 
  ggplot(aes(x, y)) +
  geom_point() +
  facet_wrap(~dataset) +
  theme_bw()
```

Ух ты ж ёш ты ж --- ничоси!

**Вывод:** цифры --- это хорошо, нужно и полезно, но недостаточно, так как они не отражают *паттернов* и всех *закономерностей*, которые нам могут быть важны для исследований. Следовательно, нельзя пренебрегать визуализациями --- как разведочными, так и результатов.



# Философия A Layered Grammar of Graphics

Идея, воплощенная в `ggplot2`, восходит к работе [L. Wilkinson «The Grammar of Graphics»](https://www.springer.com/gp/book/9780387245447). Базируясь на идеях, изложенных в этой работе, Hadley Wickham разработал концепцию [Layered Grammar of Graphics](https://doi.org/10.1198/jcgs.2009.07098) и создал мощный пакет для визуализации, ради которого мы все здесь собрались. Автором по этому пакету написана целая [книга](https://www.springer.com/gp/book/9780387981413), но мы сосредоточимся на основных смысловых и ключевых моментах, которые необходимы, чтобы сделать что-то крутое.

> Часто возникает вопрос: почему 2? Ответ примерно такой: был и первый `ggplot`, но попытка не задалась от слова совсем, и пришлось все переделать.



## Собственно к философии построения графиков

По своей сути график представляет собой сложную аппликацию из нескольких слоев. На каждом слое располагаются сходные по содержанию элементы. Начиная с самого первого --- базового --- и постепенно добавляя слой за слоем необходимые элементы, можно создавать сложные визуализации для отображения интересных закономерностей в данных.

После создания базового графика осуществляется настройка отдельных элементов по необходимости и в зависимости от требований издательства / преподавателя / научника / комиссии и т.д. И поскольку все элементы в определенной степени изолированы друг от друга, это открывает большие возможности кастомизации. Кроме того, чтобы оформить график в соответствии с конкретными требованиями, нет необходимости перерисовывать его целиком, так как содержательная часть графика независима от настроек внешнего облика. Все, что вам нужно --- это добавить/удалить пару строк кода.

Но --- хватит слов! Поехали уже рисовать уже!


## Данные

Грузим! Датасет номер раз:

```{r}
dirtDoz <- read_csv("https://raw.githubusercontent.com/angelgardt/angelgardt.github.io/master/appcogsci2022/dirtyDozen.csv")
```

Датасет номер два:
```{r}
share <- read_delim("https://raw.githubusercontent.com/angelgardt/angelgardt.github.io/master/appcogsci2022/share.csv",
                    delim = " ", locale = locale(decimal_mark = ","))
```

Датасет номер три:

```{r}
ajt <- read_csv("https://raw.githubusercontent.com/angelgardt/angelgardt.github.io/master/appcogsci2022/ajt_data.csv")
```

Сегодня у нас есть трое данных. Первые --- поведенческие. Это `share`. Это данные эксперимента, в котором пользователи Android и iOS искали иконки «share» обеих платформ среди универсальных иконок. Короче, зрительный поиск.

Переменные в датасете следующие:

* `trialtype` --- тип пробы (`tray`/`dots`/`both`)
* `setsize` --- количество стимулов в пробе (`8`/`12`/`16`)
* `time1` --- время первого клика
* `time2` --- время второго клика
* `id` --- индентификатор испытуемого
* `platform` — платформа смартфона (`Android`/`iOS`)
* `correct1` — был ли корректным первый клик (найден ли первый целевой стимул)
* `correct2` — был ли корректным второй клик (найден ли второй целевой стимул)

Вторые --- опросниковые. Это `dirtDoz`. Это данные прохождения опросника «Темная дюжина» старшеклассниками российских школ.

Переменные таковы:

* `age` --- возраст респондента
* `gender` --- гендерная принадлежность респондента (`male`/`female`/`other`)
* `class` --- класс, в котором обучается респондент
* `mac` --- балл по шкале макиавеллизма
* `nar` --- балл по шкале нарциссизма
* `psy` --- балл по шкале психопатии

Третьи --- лингвистические. Это `ajt`. Это данные исследования усвоения русского языка как второго. Информанты решали задачу AJT (acceptability judgement task), в которой необходимо было сказать, насколько представленное предложение приемлемо для русского языка. Задачу решали нейтивы и элтушники.

Переменные вот:

* `id` --- ID информанта
* `time` --- время, затраченное на выполнение всего задания (оценку приемлемости всех предложений)
* `group` --- группа информантов (русский язык родной --- `L1` / русский язык иностранный --- `L2`)
* `number` --- номер предложения
* `item` --- текст предложения
* `value` --- ответ информанта


Ну, вот с данными мы познакомились — теперь можно расчехлять кисти!



# Базовая визуализация

## Базовый слой

Когда мы собираемся рисовать, мы берем холст. Когда мы начинаем рисовать график в `ggplot2`, первое, что нам надо ему сказать --- «Дай мне холст!». На языке `ggplot2` это делается с помощью команды `ggplot()`:

```{r}
ggplot()
```

Получите --- распишитесь. `ggplot2` дал нам холст. Иначе говоря, мы построили *базовый слой*, на котором далее будем располагать элементы нашего графика.

Следующее, что нам нужно сделать, это указать данные, по которым мы будем строить нашу визуализацию. Это делается с помошью аргумента `data`:

```{r}
ggplot(data = dirtDoz)
```

Вроде бы ничего не изменилось, да и собственно, не должно было, ведь мы никак не указали, что мы хотим отобразить. Давайте укажем.


## Разметка осей

Важнейшие элементы любого графика --- это оси. Мы строим двумерные графики, поэтому и оси у нас две --- как учили в школе, `x` (горизонтальная ось, ось абсцисс) и `y` (вертикальная ось, ось ординат).

Чтобы задать оси графика потребуется отдельная функция. Она называется `aes()`, и в общем задает *эстетики графика*.


### Эстетики (aesthetics)

Итак, конкретнее об эстетиках. Иначе говоря, это то форматирование, которое связано с данными. Или еще один способ понимания: эстетики --- это способы отображения переменных из датасета. У функции `aes()` есть ряд параметров, они тоже называются эстетики.

Вот список эстетик, которые используются чаще всего: `x`, `y`, `color`, `fill`, `shape`, `size`.

Несложно догадаться, что переменные по осям задаются параметрами `x` и `y`. Что ж, зададим.

Давайте визуализируем связь между нарциссизмом и макиавеллизмом (вернее, между баллами по этим шкалам):

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac))
```

Так, ну, допустим… А где картинка?

Картинки нет, но `ggplot2` честно отработал свою работу. Мы задали только оси --- и он нам разметил их в соответствии с имеющимися в векторах значениях. Больше мы ему ничего не написали. Чтобы всё-таки получить картинку, необходимо указать, как мы хотим отборазим наши переменные.


## Геомы

За то, каким образом будут отображены переменными, а конкретно, какими «геометрическими объектами», отвечает семейство функций `geom_*`. Когда мы переходим к этой функции, мы переходим на новый слой. Чтобы это обозначить используется плюсик `+`:

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac)) +
  geom_point()
```

Мы выбрали точки для отображения переменных, потому что это наиболее наглядный вариант отобразить зависимость между двумя переменными. Такой тип графика называется *scatterplot*, или *диаграмма рассеяния*.

Но, вообще-то, можно и получше отобразить закономерность. Как минимум, добавить *линию тренда* с помощью специального геома:

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac)) +
  geom_point() +
  geom_smooth()
```

Как видите, при добавлении нового «геометрического» способа отображения данных мы добавляем новый слой.

Сейчас мы гораздо отчетливее видим, что есть некоторый тренд --- с ростом баллов по одной из шкал растут баллы и по другой. Но мы можем визуализировать закономерность ещё более явно. Так как `geom_smooth()` подразумевает «сглаживание», оно может происходить с помощью разных методов (используемый метод нам написали в консоль). Мы можем эскплицинто указать, какой метод хотим использовать. Например, линейную регрессию:

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac)) +
  geom_point() +
  geom_smooth(method = "lm")
```

Вот вам, пожалуйста, красивый линейный тренд.



## Больше информации на график

Как мы помним из структуры данных (и теории), в Тёмную Триаду входят три [^1] черты. Мы пока отобразили зависимость между двумя. Хотелось бы добавить третью и при этом не выйти в 3D --- всё-таки мы собираемся это печатать в статье.

[^1]: Шок…

### Цвет

Цвет — удивительная шкала. Она может быть дискретной и непрерывной, порядковой и категориальной. То есть, мы можем сделать вот так:

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac, color = psy)) +
  geom_point()
```

Мы задачи отображение количественной переменной с помошью цвета и эффектно отобразили связь между тремя количественными переменными на двумерном графике. Ну и кто тебе скажет, что мы не боги визуализации?


## Фасетирование

Мы уже отобразили приличное количество информации, но недостаточное. Давайте ещё нашу выборку по гендеру разобьем --- будет весело! Чтобы на одном субграфике были мальчики, а на другом девочки. Для этого есть семейство функций `facet_*()`:

```{r}
ggplot(data = dirtDoz,
       aes(nar, mac, color = psy)) +
  geom_point() +
  facet_wrap(~ gender)
```

Я обещал, что будет весело. Давайте исключим из анализа единственную небинарную персону --- заодно посмотрим, как филигранно tidyverse сплетается с `ggplot2`:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point() +
  facet_wrap(~ gender)
```

Ну, что-то такое. Вот теперь это окончательный вариант базовой визуализации. Ура!



# Настройка графика

Но рано радоваться --- время кодить, солнце ещё не взошло!

Содержание на график мы вывели, однако в таком виде публиковать его категорически нельзя. Необходимо поработать над деталями.


## Эстетики, но под другим углом

Оцените размер точек — кажется маловаты, да? Надо нарисовать их побольше. Для этого есть параметр size:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender)
```

Вот, так стало значительно приятнее и проще смотреть. Обратите внимание, что в этом случае мы задавали значение аргумента `size` вне функции `aes()`, так как он не связан с самими данными --- значение `2` мы берем извне, задаем произвольно.


## Подписи осей

Поддерживаете вы отечественного производителя или стремитесь опубликоваться в журнале «Природа» — переменные на графике должны быть подписаны нормально [^2]. То есть из подписи оси (эстетики) должно быть понятно, какой показатель отображён на графике. Что ж, подпишем.

[^2]: Ибо «нормально делай — нормально будет».

Для этого есть функция `labs()`, которая позволяет подписать [почти] всё и сразу. И это будет новый слой:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников")
```

Ну, уже как будто прилично.



## Тема

Но серый дефолтный фон до добра ещё никого не доводил. Когда-то стандартная тема `ggplot2` была очень популярна, так как позволяла заявить, что ты «могёшь в R» и «как мощны твои количественные методы», но нынче публика уже значительно искушенная в этом вопросе. Да и на самом деле, серый фон снижает контрастность, в результате чего восприятие визуализации затрудняется. Проведем этот день под лозунгом: «Даёшь контрастность каждой визуализации!»

Нам всего лишь надо сменить тему. Я люблю чёрно-белую, другие предпочитают минималистичную. Выбор за вами, но я сделаю вот так:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников") +
  theme_bw()
```

Красuво!


## Подписи фасетов

О нет! Мы же забыли исправить названия субграфиков --- они там всё ещё на латинице висят. Секундочку, щас всё будет!

Для этого нам надо завести именованный вектор: имена --- это исходные названия уровней категориальной переменной, а сами элементы вектора --- это лейблы, которые должны отображаться на графике. В нашем случае вот так:

```{r}
la <- c(male = "Мальчики",
        female = "Девочки")
```

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender,
             labeller = labeller(gender = la)) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников") +
  theme_bw()
```

Фух, слава Богу… Поправили.


## Оптимизация

Кажется, что легеда, располагающаяся справа --- это невыгодно. Почему? Нам мы хотелось показать взаимоотношения между переменными, растянув точки порише. Мы могли бы переместить легенду вниз, освободив пространство справа. Давайте так и сделаем. Для этого нам надо подправить некоторые элементы темы:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender,
             labeller = labeller(gender = la)) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников") +
  theme_bw() +
  theme(legend.position = "bottom")
```


Теперь и общая композиция симметричнее стала. Но вот маленькая напасть: подпись «Психопатия» теперь как будто проситься, чтобы её подтянули повыше --- выровняли по центру с цветовой шкалой. Штош, это потребует чуть большего количества пальцедвижений, но её прошение мы удовлетворим.

> Под капотом `ggplot2` развернута сложная система ООП, в которую мы вникать не будем, иначе нам никакого кофе не хватит. Но сейчас мы подойдём к ней максимально близко.

Подпись «Психопатия» — это, во-первых, текстовый элемент, а во-вторых, заголовок легенды. Теперь внимательно следите за руками и названиями аргументов и функций:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender,
             labeller = labeller(gender = la)) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.title = element_text(vjust = .9))
```

Мы взяли аргумент `legend.title`, который управляет заголовком легенды, а так как заголовок --- это текстовый элемент, то аргумент ждёт результата работы функции `element_text()`. Из все возможных опций управления текстом нас сейччас интересует выравнивание по вертикали (vertical justification) (`vjust`). Число подбираем визуально.

Это было непросто, но мы справились. Давайте ещё заголовок графика до кучи по центру поставим --- и отправляем в журнал:

```{r}
dirtDoz %>% 
  filter(gender != "other") %>% 
  ggplot(aes(nar, mac, color = psy)) +
  geom_point(size = 2) +
  facet_wrap(~ gender,
             labeller = labeller(gender = la)) +
  labs(x = "Нарциссизм",
       y = "Макиавеллизм",
       color = "Психопатия",
       title = "Связь черт Тёмной Триады у старших школьников") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.title = element_text(vjust = .9),
        plot.title = element_text(hjust = .5))
```


# Необычные фишечки [1]

Иногда с фасетами возникает проблема.

```{r}
ajt %>% 
  filter(cond != "ungram") %>% # убираем неграмматичное условие
  mutate(number = as.character(number)) %>% # подправляет тип переменной
  group_by(number, group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(number, score, color = group)) +
  geom_point() +
  facet_wrap(~ cond) +
  theme_bw()
```

Так как у нас часть предложений была в одном условии, часть в другом, часть в третьем и т.д., на графике мы видим «дырки» --- естественно, те предложения, которых не было в конкретном условии, не отображены на субграфике этого условия. При этом шкала у субграфиков по умолчанию общая. Хоцца сделать так, чтобы было не общая.

```{r}
ajt %>% 
  filter(cond != "ungram") %>%  # убираем неграмматичное условие
  mutate(number = as.character(number)) %>% # подправляет тип переменной
  group_by(number, group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(number, score, color = group)) +
  geom_point() +
  facet_wrap(~cond, scales = "free_x") +
  theme_bw()
```

Теперь красивое.

Так как эта визуализация разведочная, возможно, есть смысл вынесли на график не номера предложений, а сразу сами предложения. Вот так:

```{r}
ajt %>% 
  filter(cond != "ungram") %>%  # убираем неграмматичное условие
  group_by(item, group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(item, score, color = group)) +
  geom_point() +
  facet_wrap(~cond, scales = "free_x") +
  theme_bw()
```

Боже, как плохо. Давайте что ли оси перевернем…

```{r}
ajt %>% 
  filter(cond != "ungram") %>%  # убираем неграмматичное условие
  group_by(item, group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(item, score, color = group)) +
  geom_point() +
  coord_flip() +
  facet_wrap(~ cond, ncol = 1, scales = "free_y") + # поменяли ось
  theme_bw()
```

А еще может быть другая проблема:

```{r}
ajt %>% 
  filter(cond != "ungram") %>%  # убираем неграмматичное условие
  group_by(group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(cond, score, fill = group)) +
  geom_col(position = position_dodge()) +
  theme_bw()
```

Вроде все приемлемо, однако ось `y` у нас начинается с 0, хотя минимальное значение по шкале оценки премлемости была 1. Надо поправить:

```{r}
ajt %>% 
  filter(cond != "ungram") %>%  # убираем неграмматичное условие
  group_by(group, cond) %>% # группируем по условиям
  summarise(score = mean(value)) %>% # усредняем ответы информантов
  ggplot(aes(cond, score, fill = group)) +
  geom_col(position = position_dodge()) +
  coord_cartesian(ylim = c(1, 5)) +
  theme_bw()
```



# Встроенная статистическая обработка

Хорошо. На простеньком мы размялись --- теперь надо сделать что-то посерьёзнее.

Часто бывает так, что мы хотим отобразить на графике не сырые данные, а какие-либо посчитанные статистики. Получается, сначала надо предобработать данные, получить необходимые значения, а затем на основе них строить график.

Но зачем? Если можно сразу в коде построения графика рассчитать все, что нам нужно! В `ggplot2` уже встроены инструменты простейшей статистический обработки!

Посмотрим, как влияют на [среднее] время реакции различные экспериментальные условия. Начнём с самого простого --- количества стимулов на экране.




## Статы

Статы --- это те самые встроенные инструменты статистической обработки. Они позволяют прямо в коде графика обсчитать данные и сразу визуализировать результаты.

> На самом деле, мы уже сталкивались со встроенными инструментами статистической обработки, ведь что делает `geom_smooth(method = "lm")`? Не что иное, как визуализирует линейную регрессию, построенную на выбранных данных!

Наиболее популярная функция из семейства `stat_*()` --- это `stat_summary()`. С помощью неё можно удобно визуализировать средние.

Сразу зададим черно-белую тему на все последующие визуализации. Это делается так:

```{r}
theme_set(theme_bw())
```

Итак, мы хотим понять, как зависит среднее время реакции от количества стимулов. Нас будут интересовать пробы с одним целевым стимулом, поэтому отфильтруем все остальные, а также сразу расчертим базовый слой:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(setsize, time1))
```

Так, обратим внимание на следующий момент: на оси `x` обозначились числа 10 и 14, а таких сетсайзов в данных нет. Можем убедиться:

```{r}
unique(share$setsize)
```

Это случилось потому, что переменная `setsize` записана в датасете как числовая, а для вычисления среднего времени реакции в каждом из условий будет нужна группировка наблюдений. По числовой переменной группировка невозможна, поэтому необходимо прописать, что данную переменную мы будем рассматривать как фактор:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1))
```

Во, теперь как надо.

Теперь добавляем средние. Как и полагается, на новый слой:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1)) +
  stat_summary(fun = mean, geom = "point")
```

Разберемся, что тут написано. Первый аргумент (`fun`) принимает функцию, результат которой будет отложен по оси `y`. В нашем случае это среднее (`mean`). Она будет применена к переменой `time1`, причем наблюдения будут автоматически сгруппированы по интересующим нас группам. Второй аргумент --- это уже знакомый нам геом, который отвечает за то, как «геометрически» будут отрисованы знаечния на графике. Наш выбор --- точки. Как результат мы наблюдаем то, что хотели.

Однако как мы знаем из статистики, чтобы узнать, есть ли различия между условиями, нам недостаточно только средних значений --- необходимы доверительные интервалы. Что ж, отобразим и их.

Добавим новый слой с помощью всё той же функции `stat_summary()`, но на этот раз она будет выглядеть немного по-другому:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar")
```

Как мы видим, немного изменился первый аргумент. Это связано с изменением геома. Для отображения доверительных интервалов нам нужен геом `errorbar`, который требует не одно значение, а два — верхнюю и нижнюю границу доверительного интервала. То есть `fun.data` принимает как аргумент мини-датафрейм — как раз в таком формате и возвращается результат функции `mean_cl_boot()`. Можно посмотреть на её работу отдельно:

```{r}
mean_cl_boot(share$time1)
```

Собственно, вот он датафрейм из одной строки. Здесь три значения, но errorbar игронирует первое (оно и есть среднее значение) и использует только второе и третье, строя по ним «усы».

Собственно, график почти готов, однако добавим линии, которые будут соединять наши средние. Это допустимо в данной визуализации, так как мы отображаем повторные измерения и так более наглядно будет прослеживаться закономерность.

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar") +
  stat_summary(fun = mean, geom = "line")
```

Ага, вроде слой добавили, но ничего не изменилось. Еще и *warning* вылетел. Надо почитать!

`ggplot2` нам говорит, что каждая группа у нас содержит одно наблюдение --- и он категорически прав, ведь у нас в каждой группе отображается только среднее значение. Из-за этого он не понимает, как ему нужно соединять точки. Надо ему подсказать, что с точки зрения соединения точек у нас всего одна группа, так как мы хотим, чтобы наши средние были последовательно соединены. Так и запишем (используя аргумент `group`):

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar") +
  stat_summary(fun = mean, geom = "line",
               aes(group = 1))
```

Вот такая у нас классная линейная закономерность получилась! Ну, а чего мы ждали --- зрительный поиск же…


## Добавляем переменных

Окей, как влияет число стимулов мы поняли. Теперь хотим посмотреть, как на этом фоне ведут себя другие факторы. Добавим тип пробы. Обозначим его, например, цветом:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar") +
  stat_summary(fun = mean, geom = "line",
               aes(group = 1))
```

О, хорошо. Только с линией теперь надо что-то делать. Пока её уберём. И добавим ещё один фактор --- используемая платформа смартфона. Пусть он обозначается формой точек:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar")
```

Уф… Ну, групировка прошла успешно --- уже хорошо, однако отображение хромает. Надо немного раздвинуть точки относительно друг друга в отдельных категориях, так как сейчас они явно друг на друга налезают. Для этого есть аргумент position, который принимает результат выполнения функции `position_dodge()` [^3].

[^3]: Есть и другие `position_*()`, но мы их упустим

```{r}
pd <- position_dodge(.3)
```

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform)) +
  stat_summary(fun = mean, geom = "point",
               position = pd) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd)
```

Ага, ну, норм. Только «усы» доверительных интервалов широки — надо сделать их поуже:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform)) +
  stat_summary(fun = mean, geom = "point",
               position = pd) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3)
```

Красuво!

Осталось только понять, как бы нам вернуть линии. Осмыслим, что нам надо соединить красные треугольники между собой, зелёные треугольники между собой, красный точки между собой и зелёные точки между собой. То есть группы точек у нас получаются в результате взаимодействия факторов. Так и напишем:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd)
```


## Наводим красоту

Сделаем то, что мы уже умеем: увеличим размер точек, сдвинем легенду вниз, подпишем переменные. Попутно сделаем линни пунктирными, чтобы не сильно отвлекали внимание:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd, linetype = "dashed", alpha = .7) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd, size = 3) +
  labs(x = "Количество стимулов в пробе",
       y = "Время реакции (первый клик), с",
       color = "Тип пробы",
       shape = "Платформа",
       title = "Время реакции при взаимодействии факторов",
       subtitle = "Тип пробы × Платформа × Количество стимулов в пробе") +
  theme(legend.position = "bottom")
```


Оч хор. Вот только мы отобразили интервальную оценку на графике, а ведь это может быть не только доверительный интервал --- так же выглядит и стандартная ошибка и даже стандартное отклонение. Надо подписать в подписи:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd, linetype = "dashed", alpha = .7) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd, size = 3) +
  labs(x = "Количество стимулов в пробе",
       y = "Время реакции (первый клик), с",
       color = "Тип пробы",
       shape = "Платформа",
       title = "Время реакции при взаимодействии факторов",
       subtitle = "Тип пробы × Платформа × Количество стимулов в пробе",
       caption = "отображен 95% доверительный интервал") +
  theme(legend.position = "bottom")
```

Ну, почти всё. Осталось только красиво подписать платформы и типы проб. Для этого есть функции семейства `scale_*()`. Работает это так:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd, linetype = "dashed", alpha = .7) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd, size = 3) +
  labs(x = "Количество стимулов в пробе",
       y = "Время реакции (первый клик), с",
       color = "Тип пробы",
       shape = "Платформа",
       title = "Время реакции при взаимодействии факторов",
       subtitle = "Тип пробы × Платформа × Количество стимулов в пробе",
       caption = "отображен 95% доверительный интервал") +
  scale_color_discrete(labels = c("Three Dots", "Outgoing Tray")) +
  scale_shape_discrete(labels = c("Android", "iOS")) +
  theme(legend.position = "bottom")
```

Супер! Отправляем в журнал!


## Кастомизация шкал

Но недолго мы радовались: пришло письмо от редактора. Краткое содержание --- «очень хороший, отличный, прекрасный график! переделайте, пожалуйста». Редактору не понравилось использование цвета --- журнал печатается в черно-белом варианте.

Ок, секудочку.

Мы уже приступили к кастомизации шкал, когда задавали лейблы для уровней наших категориальных переменных. Теперь включим кастом на всю силу --- используем функции `scale_*_manual()`:

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd, linetype = "dashed", alpha = .7) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd, size = 3) +
  labs(x = "Количество стимулов в пробе",
       y = "Время реакции (первый клик), с",
       color = "Тип пробы",
       shape = "Платформа",
       title = "Время реакции при взаимодействии факторов",
       subtitle = "Тип пробы × Платформа × Количество стимулов в пробе",
       caption = "отображен 95% доверительный интервал") +
  scale_color_manual(values = c("gray50", "black"),
                     labels = c("Three Dots", "Outgoing Tray")) +
  scale_shape_discrete(labels = c("Android", "iOS")) +
  theme(legend.position = "bottom")
```

Здесь мы задаём цвета через [названия](https://github.com/angelgardt/mk_ggplot2/blob/master/Rcolor.pdf). Можно также использовать [HEX code](https://www.w3schools.com/colors/colors_hexadecimal.asp).

## Шрифт

Ещё редактору не понравился шрифт без засечек --- он хочет Times New Roman.

Ок, секудочку.

```{r}
share %>% 
  filter(trialtype != "both") %>% 
  ggplot(aes(as_factor(setsize), time1,
             color = trialtype,
             shape = platform,
             group = interaction(trialtype, platform))) +
  stat_summary(fun = mean, geom = "line",
               position = pd, linetype = "dashed", alpha = .7) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
               position = pd, width = .3) +
  stat_summary(fun = mean, geom = "point",
               position = pd, size = 3) +
  labs(x = "Количество стимулов в пробе",
       y = "Время реакции (первый клик), с",
       color = "Тип пробы",
       shape = "Платформа",
       title = "Время реакции при взаимодействии факторов",
       subtitle = "Тип пробы × Платформа × Количество стимулов в пробе",
       caption = "отображен 95% доверительный интервал") +
  scale_color_manual(values = c("gray50", "black"),
                     labels = c("Three Dots", "Outgoing Tray")) +
  scale_shape_discrete(labels = c("Android", "iOS")) +
  theme(legend.position = "bottom",
        title = element_text(family = "Times New Roman"),
        plot.title = element_text(face = "bold"),
        axis.text = element_text(family = "Times New Roman"),
        legend.text = element_text(family = "Times New Roman"))
```

Ну, вот теперь редактор доволен.


# Сохранение графиков

Для того, чтобы опубликовать график в статье или даже просто вставить в презентацию нужно его как-то выгрузить. Скриншоты нам не подходят, потому что качество их совершенно никуда не годится. На наше счастье есть фукнция для выгрузки картинок из `R` и называется она `ggsave()`.

Она принимает следующие аргументы:

* `filename` --- название файла, в которых будет сохранен график
* `plot` --- график, который необходимо сохранить (по умолчанию, последний построенный)
* `scale` --- степень масштабирования изображения
* `width` --- ширина изображения
* `height` --- высота изображения
* `units` --- единицы изменения (дюймы, миллиметры, сантиметры)
* `dpi` --- разрешение изображения (точки на дюйм)

Функция позволяет сохранить изображения большинства форматов (JPEG, PNG, SVG, TIFF, PDF).

```{r}
ggsave('graph1.png', width = 20, height = 20, units = 'cm', dpi = "print")
```

Выполнив эту функцию мы получим в рабочей директории файл с графиком, который мы только что нарисовали.

> Вот и весь основной flow, которому можно следовать при создании публикабельных графиков. А если этого уже мало, то вполне можно нырять в [невероятное чтиво](https://www.springer.com/gp/book/9780387981413) и бороздить [Google](https://google.com/) вопросами о конкретных вещах --- на [Stack Overflow](https://stackoverflow.com/) найдется ответ практически на любой вопрос. Успехов!



# Необычные фишечки [2]

> Для искушенных

Пошалим! Возьмем опросник:

```{r}
taia <- read_csv("https://raw.githubusercontent.com/angelgardt/angelgardt.github.io/master/appcogsci2022/taia_sample.csv")
```

Предобработаем --- посчитаем суммарный балл по шкалам:

```{r}
taia %>% 
  pivot_longer(1:60, names_to = "item", values_to = "score") %>% 
  mutate(subscale = str_remove_all(item, "[:digit:]{2}") %>% toupper()) %>%
  group_by(id, subscale) %>% 
  summarise(subscale_score = sum(score))
```

Попробуем отобразить профили нескольких респондентов. Например, 5-го, 23-го и 50-го. Заодно и крусоту наведем.

```{r}
taia %>% 
  pivot_longer(1:60, names_to = "item", values_to = "score") %>% 
  mutate(subscale = str_remove_all(item, "[:digit:]{2}") %>% toupper()) %>%
  group_by(id, subscale) %>% 
  summarise(subscale_score = sum(score)) %>% 
  filter(id == 5 | id == 23 | id == 50) %>% 
  ggplot(aes(subscale, subscale_score, fill = subscale)) +
  geom_col() +
  geom_label(aes(label = subscale_score)) +
  facet_wrap(~ id) +
  coord_polar() +
  theme(axis.title.x = element_text(size = 0),
        axis.text.x = element_text(size = 0))
```

Как это получилось? Обратите внимание на геомы: по факту мы построили столбчатую диаграмму --- `geom_col()`. Второй геом `geom_label()` всего лишь навесил нам циферки в квадратиках. С фасетами мы тоже уже знакомы.

А потом мы сделали `coord_polar()`. Здесь нам надо вспомнить, что существует не только декартова система координат. В данном случае мы завернули привычный нам график в декартовых координатах в [*полярную систему координат*](https://ru.wikipedia.org/wiki/Полярная_система_координат). Давайте посмотрим на график без `coord_polar()`:

```{r}
taia %>% 
  pivot_longer(1:60, names_to = "item", values_to = "score") %>% 
  mutate(subscale = str_remove_all(item, "[:digit:]{2}") %>% toupper()) %>%
  group_by(id, subscale) %>% 
  summarise(subscale_score = sum(score)) %>% 
  filter(id == 5 | id == 23 | id == 50) %>% 
  ggplot(aes(subscale, subscale_score, fill = subscale)) +
  geom_col() +
  geom_label(aes(label = subscale_score)) +
  facet_wrap(~ id) +
  # coord_polar() +
  theme(axis.title.x = element_text(size = 0),
        axis.text.x = element_text(size = 0))
```

Реально же, все крайне привычно! В `theme()` в данном случае убрана дублируемая информация, так как для наглядности `subscale` отображены также цветом заливки.

А еще можно пилить мемы:

```{r}
taia %>% 
  pivot_longer(1:60, names_to = "item", values_to = "score") %>% 
  mutate(subscale = str_remove_all(item, "[:digit:]{2}") %>% toupper()) %>%
  group_by(id) %>% 
  summarise(total_score = sum(score)) %>% 
  ggplot(aes(id, total_score)) +
  geom_point() +
  annotate("rect", xmin = 16, xmax = 22, ymin = 125, ymax = 140,
           fill = "darkblue", alpha = .5) +
  annotate("text", x = 28, y = 130,
           label = "низкий балл", color = "darkblue") +
  annotate("rect", xmin = 20, xmax = 25, ymin = 110, ymax = 120,
           fill = "darkgreen", alpha = .5) +
  annotate("text", x = 35, y = 115,
           label = "балл по менбше", color = "darkgreen") +
  annotate("rect", xmin = 35, xmax = 40, ymin = 77, ymax = 87,
           fill = "darkred", alpha = .5) +
  annotate("text", x = 40, y = 75,
           label = "ваще маленький балл жесть…", color = "darkred")
```

<center>
![](cats_meme.jpeg)
</center>

Вот такое можно изображать в ггплоте.
